// Script:    TesteVerificaLista.script
// Autor:     Guilherme Dantas
// Data:      30/11/2018 - 02/11/2018
// Propósito: Testa a função deturpa e verifica na estrutura de LISTA
//

== Inicializar valores
=declararparm   lista0  int 0
=declararparm   lista1  int 1
=declararparm   lista2  int 2
=declararparm   lista3  int 3
=declararparm   lista4  int 4
=declararparm   lista5  int 5
=declararparm   lista6  int 6
=declararparm   lista7  int 7

=declararparm   espacolixo int 999

=declararparm   str0    string  "abcdefg"
=declararparm   str1    string  "qwerty"
=declararparm   str2    string  "xxx"
=declararparm   str3    string  "xpto"

=declararparm   corr	string  "ElemCorr"

=declararparm   OK             int  0
=declararparm   ListaVazia     int  1
=declararparm   FimLista       int  2
=declararparm   NaoAchou       int  3
=declararparm   FaltouMemoria  int  4
=declararparm   ErroEstrutura  int  5
=declararparm   ErroParam      int  6

=declararparm   pNULL          int  0
=declararparm   pNaoNULL       int  1

=declararparm   DeturpaEliminaCorr    int 1
=declararparm   DeturpaProxNULL       int 2
=declararparm   DeturpaAntNULL        int 3
=declararparm   DeturpaProxLixo       int 4
=declararparm   DeturpaAntLixo        int 5
=declararparm   DeturpaConteudoNULL   int 6
=declararparm   DeturpaAlteraTipoNo   int 7
=declararparm   DeturpaDesencadeiaNo  int 8
=declararparm   DeturpaPontCorrNULL   int 9
=declararparm   DeturpaPontOrigNULL   int 10
=declararparm   DeturpaPontFimNULL    int 11
=declararparm   DeturpaEliminaLista   int 12
=declararparm   DeturpaCorrLixo       int 13
=declararparm   DeturpaOrigLixo       int 14
=declararparm   DeturpaFinalLixo      int 15
=declararparm   DeturpaNumElemNeg     int 16
=declararparm   DeturpaCorrElemNovo   int 17
=declararparm   DeturpaCorrPontLista  int 18
=declararparm   DeturpaOrigPontLista  int 19
=declararparm   DeturpaFinalPontLista int 20
=declararparm   DeturpaOrigElemNovo   int 21
=declararparm   DeturpaElemCabNULL    int 22
=declararparm   DeturpaDuplicaElem    int 23

=declararparm	ArqDefCnt      	string "DefContadoresLista.def"
=declararparm   ArqCntSaida     string "ContadoresLista.count"

== Inicializar contador
=inicializarcontadores ""
=lercontadores ArqDefCnt
=registraracumulador ArqCntSaida
=iniciarcontagem

== Verificar lista vazia
=verificar lista0 1
=AceitaFalhasAcumuladas 1

== Criar lista
=criarlista lista0
=verificar lista0 0

== Deturpar ponteiro fim, orig e corr, mas a lista é vazia então OK
=deturpar lista0 DeturpaPontCorrNULL
=deturpar lista0 DeturpaPontOrigNULL
=deturpar lista0 DeturpaPontFimNULL
=verificar lista0 0

== CONTADOR 1 >> Deturpar ponteiro fim, orig e corr para lista com um elemento
=inselemapos lista0 str0 OK
=deturpar lista0 DeturpaPontCorrNULL
=deturpar lista0 DeturpaPontOrigNULL
=deturpar lista0 DeturpaPontFimNULL
=verificar lista0 5
=AceitaFalhasAcumuladas 5
=destruirlista lista0

== CONTADOR 2 >> Deturpar ponteiro para lista, liberando-a com free ( pLista != NULL )
=criarlista lista0
=verificar lista0 0
=deturpar lista0 DeturpaEliminaLista
=verificar lista0 1
=AceitaFalhasAcumuladas 1
// Não é preciso destruir a lista, pois já foi liberada

== CONTADOR 3 >> Verificar ponteiro que não aponta para uma lista
=verificar espacolixo 1
=AceitaFalhasAcumuladas 1

== CONTADORES 4,5,6 >> Deturpar lista para que ponteiros da cabeça aponte para lixo
=criarlista lista1
=inselemantes lista1 str0 OK
=deturpar lista1 DeturpaCorrLixo
=deturpar lista1 DeturpaOrigLixo
=deturpar lista1 DeturpaFinalLixo
=verificar lista1 3
=AceitaFalhasAcumuladas 3
=tornarinativos
=liberarinativos 3
=AceitaFalhasAcumuladas 3
// Os três espaços que vazaram são a lista, a estrutura e o elemento.
// [!] Não é chamada a função de destruir a lista, pois o programa voará, já que
// acessa ao ponteiro origem, que está com LIXO!

== CONTADORES 4b,5b,6b >> Deturpar lista para que ponteiros da cabeça aponte para a lista
=criarlista lista2
=inselemantes lista2 str0 OK
=deturpar lista2 DeturpaCorrPontLista
=deturpar lista2 DeturpaOrigPontLista
=deturpar lista2 DeturpaFinalPontLista
=verificar lista2 3
=AceitaFalhasAcumuladas 3
=tornarinativos
=liberarinativos 3
=AceitaFalhasAcumuladas 3
// [!] Não é chamada a função de destruir a lista, pois o programa voará, já que
// acessa ao ponteiro origem, que está apontando para LISTA!

== CONTADORES 7-10 >> Deturpa lista, desencadeando nó corrente, mas sem liberá-lo
=criarlista lista3
=inselemapos lista3 str0 OK
=inselemapos lista3 str1 OK
=inselemapos lista3 str2 OK
=avancarelem lista3 -1 OK
=obtervalorelem lista3 str1 pNaoNULL
=deturpar lista3 DeturpaDesencadeiaNo
=verificar lista3 5
=AceitaFalhasAcumuladas 5
// Não há vazamento pois o ponteiro pCorr da cabeça ainda aponta para o elemento desencadeado
// Como perecebeu-se a contagem de elementos diferiu da calculada através do percorrimento
// da lista por ambos os sentidos.
=destruirlista lista3
=tornarinativos
=liberarinativos 2
=AceitaFalhasAcumuladas 2
// Aqui são liberados dois espaços: o elemento e estrutura desencadeados.
// Não foram liberados na função Destruirlista pois esta não faz uso do ponteiro para
// elemento corrente mas sim do ponteiro para origem.

== CONTADOR 11 >> Deturpa contador de elementos para número negativo
=criarlista lista3
=inselemapos lista3 str0 OK
=deturpar lista3 DeturpaNumElemNeg
=verificar lista3 4
=AceitaFalhasAcumuladas 4
// Além de verificado que o número não corresponde ao número real de elementos na lista,
// o verificador percebe que o número de elementos é negativo.
=destruirlista lista3

== CONTADOR 12 >> Deturpa ponteiro corrente de lista vazia para apontar para novo elemento
=criarlista lista4
=deturpar lista4 DeturpaCorrElemNovo
=verificar lista4 1
=AceitaFalhasAcumuladas 1
=destruirlista lista4
=tornarinativos
=liberarinativos 2
=AceitaFalhasAcumuladas 2
// É necessário liberar o elemento e a estrutura, pois a função DestruirLista não
// leva em consideração o ponteiro pCorr porque assume que este aponta para um elemento
// pertecente à lista (através dos ponteiros pOrigem e pFinal)

== CONTADORES 15, 17, 19 >> Deturpa lista unitária ao anular ponteiro corrente
=criarlista lista5
=inselemapos lista5 str0 OK
=deturpar lista5 DeturpaPontCorrNULL
=verificar lista5 5
=AceitaFalhasAcumuladas 5
=destruirlista lista5
// Como o ponteiro corrente é nulo, não é possível localizá-lo ao percorrer a lista
// Além disso, foi sinalizado que pCorr = pOrig para numElem = 1 e que pCorr = pFinal
// para numElem = 1, o que é coerente.

== CONTADOR 18 >> Deturpa lista unitária com origem apontando para outro elemento
=criarlista lista6
=inselemapos lista6 str0 OK
=deturpar lista6 DeturpaOrigElemNovo
=verificar lista6 4
=AceitaFalhasAcumuladas 4
=destruirlista lista6
=tornarinativos
=liberarinativos 2
=AceitaFalhasAcumuladas 2
// Não achou elemento corrente ao pecorrer pela origem pois a origem aponta para
// outro elemento. Já pelo final, o elemento corrente foi achado normalmente.
// Naturalmente, pOrigem e pFinal são diferente, como é o foco principal desse caso
// de teste. A mesma coisa para pOrigem e pCorr.
// O elemento da lista original não é excluído pois pOrigem aponta para outro
// elemento (criado ""artificialmente""). Portanto este elemento e a estrutura
// que aponta devem ser liberados.

== CONTADOR 20 >> Deturpa lista com mais de um elemento ao anular ponteiro corrente
=criarlista lista6
=inselemapos lista6 str0 OK
=inselemapos lista6 str1 OK
=inselemapos lista6 str2 OK
=deturpar lista6 DeturpaPontCorrNULL
=verificar lista6 3
=AceitaFalhasAcumuladas 3
=destruirlista lista6

== CONTADOR 25 >> Deturpa elemento corrente, fazendo pCab nulo
=criarlista lista6
=inselemapos lista6 str0 OK
=deturpar lista6 DeturpaElemCabNULL
=verificar lista6 1
=AceitaFalhasAcumuladas 1
=destruirlista lista6

== CONTADORES 26-29 >> Deturpa lista, duplicando elemento corrente
=criarlista lista6
=inselemapos lista6 str0 OK
=inselemapos lista6 str1 OK
=inselemapos lista6 str2 OK
=avancarelem lista6 -1 OK
=obtervalorelem lista6 str1 pNaoNULL
=deturpar lista6 DeturpaDuplicaElem
=verificar lista6 2
=AceitaFalhasAcumuladas 2
=deturpar lista6 DeturpaAntNULL
=verificar lista6 3
=AceitaFalhasAcumuladas 3
// Elemento corrente não é origem mas tem pAnt nulo, não interferindo na
// contagem de números por percurso. Além disso, causa erro de encadeamento
// pela direita e o percurso do final para origem não acha o elemento
// corrente pela configuração dos ponteiros pAnt e pProx.
=avancarelem lista6 1 OK
=avancarelem lista6 -1 OK
=verificar lista6 2
=AceitaFalhasAcumuladas 2
// Esta é um pouco difícil de entender. Basicamente, temos uma lista em que,
// se caminharmos da origem para o final, perpassamos o elemento corrente,
// mas se caminharmos do final para a origem, perpassamos o elemento clonado
// ( mesmo pCab, pProx, pAnt ). Isso nos permite verificar dois contadores
// que dizem respeito ao fundamento básico de uma lista duplamente encadeada:
// O caminho que se faz em um sentido é o oposto do que se faz pelo outro,
// que é desobedecido nesse caso de teste.
=deturpar lista6 DeturpaProxNULL
=verificar lista6 3
=AceitaFalhasAcumuladas 3
// Elemento clonado não é final mas tem pProx nulo, não interferindo na
// contagem de números por percurso. Além disso, causa erro de encadeamento
// pela esquerda e o percurso da origem para o final não acha o elemento
// clonado pela configuração dos ponteiros pAnt e pProx.
=destruirlista lista6
=tornarinativos
=liberarinativos 2
=AceitaFalhasAcumuladas 2
// O espaço clonado não é liberado pois quando a lista é percorrida pela
// função DestruirLista, vai da origem para o final. Portanto, deve-se
// liberar tanto este elemento clonado quanto a estrutura apontada por ele.

== CONTADOR 30 >> Deturpa tipo de valor do elemento corrente
=criarlista lista7
=inselemapos lista7 str0 OK
=deturpar lista7 DeturpaAlteraTipoNo
=verificar lista7 1
=AceitaFalhasAcumuladas 1
=destruirlista lista7
=tornarinativos
=liberarinativos 0

== Terminar contador
=pararcontagem
=gravarcontadores ArqCntSaida
=verificarcontagens 0
=terminarcontadores

// fim